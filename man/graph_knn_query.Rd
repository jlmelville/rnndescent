% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rnndescent.R
\name{graph_knn_query}
\alias{graph_knn_query}
\title{Find Nearest Neighbors and Distances}
\usage{
graph_knn_query(
  query,
  reference,
  reference_graph,
  k = NULL,
  metric = "euclidean",
  init = NULL,
  epsilon = 0.1,
  use_alt_metric = TRUE,
  n_threads = 0,
  grain_size = 1,
  verbose = FALSE
)
}
\arguments{
\item{query}{Matrix of \code{n} query items.}

\item{reference}{Matrix of \code{m} reference items. The nearest neighbors to the
items in \code{query} are calculated from this data.}

\item{reference_graph}{Search graph of the \code{reference} data. A neighbor
graph, such as that output from \code{\link[=nnd_knn]{nnd_knn()}} can be used, but
preferably a suitably prepared sparse search graph should be used, such as
that output by \code{\link[=prepare_search_graph]{prepare_search_graph()}}.}

\item{k}{Number of nearest neighbors to return. Optional if \code{init} is
specified.}

\item{metric}{Type of distance calculation to use. One of \code{"euclidean"},
\code{"l2sqr"} (squared Euclidean), \code{"cosine"}, \code{"manhattan"},
\code{"correlation"} (1 minus the Pearson correlation), or
\code{"hamming"}.}

\item{init}{Initial \code{query} neighbor graph to optimize. If not
provided, \code{k} random neighbors from \code{reference} are used. The
format should be the same as the return value of this function, a list
containing:
\itemize{
\item \code{idx} a \code{n} by \code{k} matrix containing the nearest neighbor indices
specifying the row of the neighbor in \code{reference}.
\item \code{dist} (optional) a \code{n} by \code{k} matrix containing the nearest neighbor
distances.
}

If \code{k} and \code{init} are provided then \code{k} must be equal to or smaller than
the number of neighbors provided in \code{init}. If smaller, only the \code{k}
closest value in \code{init} are retained. If the input distances are omitted,
they will be calculated for you.}

\item{epsilon}{Controls trade-off between accuracy and search cost, by
specifying a distance tolerance on whether to explore the neighbors of
candidate points. The larger the value, the more neighbors will be
searched. A value of 0.1 allows query-candidate distances to be 10\% larger
than the current most-distant neighbor of the query point, 0.2 means 20\%,
and so on. Suggested values are between 0-0.5, although this value is
highly dependent on the distribution of distances in the dataset (higher
dimensional data should choose a smaller cutoff). Too large a value of
\code{epsilon} will result in the query search approaching brute force
comparison. Use this parameter in conjunction with
\code{\link[=prepare_search_graph]{prepare_search_graph()}} to prevent excessive run time. Default is 0.1.}

\item{use_alt_metric}{If \code{TRUE}, use faster metrics that maintain the
ordering of distances internally (e.g. squared Euclidean distances if using
\code{metric = "euclidean"}), then apply a correction at the end. Probably
the only reason to set this to \code{FALSE} is if you suspect that some
sort of numeric issue is occurring with your data in the alternative code
path.}

\item{n_threads}{Number of threads to use.}

\item{grain_size}{Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Ignored if \code{n_threads < 1}.}

\item{verbose}{If \code{TRUE}, log information to the console.}
}
\value{
the approximate nearest neighbor graph as a list containing:
\itemize{
\item \code{idx} a \code{n} by \code{k} matrix containing the nearest neighbor indices
specifying the row of the neighbor in \code{reference}.
\item \code{dist} a \code{n} by \code{k} matrix containing the nearest neighbor distances.
}
}
\description{
Find Nearest Neighbors and Distances
}
\examples{
# 100 reference iris items
iris_ref <- iris[iris$Species \%in\% c("setosa", "versicolor"), ]

# 50 query items
iris_query <- iris[iris$Species == "versicolor", ]

# First, find the approximate 4-nearest neighbor graph for the references:
iris_ref_graph <- nnd_knn(iris_ref, k = 4)

# For each item in iris_query find the 4 nearest neighbors in iris_ref.
# You need to pass both the reference data and the reference graph.
# If you pass a data frame, non-numeric columns are removed.
# set verbose = TRUE to get details on the progress being made
iris_query_nn <- graph_knn_query(iris_query, iris_ref, iris_ref_graph,
  k = 4, metric = "euclidean", verbose = TRUE
)
}
\references{
Hajebi, K., Abbasi-Yadkori, Y., Shahbazi, H., & Zhang, H. (2011, June).
Fast approximate nearest-neighbor search with k-nearest neighbor graph.
In \emph{Twenty-Second International Joint Conference on Artificial Intelligence}.

Harwood, B., & Drummond, T. (2016).
Fanng: Fast approximate nearest neighbour graphs.
In \emph{Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition}
(pp. 5713-5722).

Iwasaki, M., & Miyazaki, D. (2018).
Optimization of indexing based on k-nearest neighbor graph for proximity
search in high-dimensional data.
\emph{arXiv preprint arXiv:1810.07355}.
}
