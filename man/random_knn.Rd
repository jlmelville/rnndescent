% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rnndescent.R
\name{random_knn}
\alias{random_knn}
\title{Randomly select nearest neighbors.}
\usage{
random_knn(data, k, metric = "euclidean", n_threads = 0,
  grain_size = 1, verbose = FALSE)
}
\arguments{
\item{data}{Matrix of \code{n} items to generate random neighbors for.}

\item{k}{Number of nearest neighbors to return.}

\item{metric}{Type of distance calculation to use. One of \code{"euclidean"},
\code{"l2"} (squared Euclidean), \code{"cosine"}, \code{"manhattan"}
or \code{"hamming"}.}

\item{n_threads}{Number of threads to use..}

\item{grain_size}{Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Ignored if \code{n_threads < 1}.}

\item{verbose}{If \code{TRUE}, log information to the console.}
}
\value{
a list containing:
\itemize{
  \item \code{idx} an n by k matrix containing the nearest neighbor
  indices.
  \item \code{dist} an n by k matrix containing the nearest neighbor
   distances.
}
}
\description{
Randomly select nearest neighbors.
}
\examples{
# Find 4 random neighbors and calculate their Euclidean distance
# If you pass a data frame, non-numeric columns are removed
iris_nn <- random_knn(iris, k = 4, metric = "euclidean")

# Manhattan (l1) distance
iris_nn <- random_knn(iris, k = 4, metric = "manhattan")

# Multi-threading: you can choose the number of threads to use: in real
# usage, you will want to set n_threads to at least 2
iris_nn <- random_knn(iris, k = 4, metric = "manhattan", n_threads = 1)

# Use verbose flag to see information about progress
iris_nn <- random_knn(iris, k = 4, metric = "euclidean", verbose = TRUE)

# These results can be improved by nearest neighbors descent. You don't need
# to specify k here because this is worked out from the initial input
iris_nn <- nnd_knn(iris, init = iris_nn, metric = "euclidean", verbose = TRUE)
}
