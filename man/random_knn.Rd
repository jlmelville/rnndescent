% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rnndescent.R
\name{random_knn}
\alias{random_knn}
\title{Randomly select nearest neighbors.}
\usage{
random_knn(
  data,
  k,
  metric = "euclidean",
  use_alt_metric = TRUE,
  order_by_distance = TRUE,
  n_threads = 0,
  block_size = 4096,
  grain_size = 1,
  verbose = FALSE
)
}
\arguments{
\item{data}{Matrix of \code{n} items to generate random neighbors for.}

\item{k}{Number of nearest neighbors to return.}

\item{metric}{Type of distance calculation to use. One of \code{"euclidean"},
\code{"l2sqr"} (squared Euclidean), \code{"cosine"}, \code{"manhattan"},
\code{"correlation"} (1 minus the Pearson correlation), or
\code{"hamming"}.}

\item{use_alt_metric}{If \code{TRUE}, use faster metrics that maintain the
ordering of distances internally (e.g. squared Euclidean distances if using
\code{metric = "euclidean"}), then apply a correction at the end. Probably
the only reason to set this to \code{FALSE} is if you suspect that some
sort of numeric issue is occurring with your data in the alternative code
path.}

\item{order_by_distance}{If \code{TRUE} (the default), then results for each
item are returned by increasing distance. If you don't need the results
sorted, e.g. you are going to pass the results as initialization to another
routine like \code{\link{nnd_knn}}, set this to \code{FALSE} to save a
small amount of computational time.}

\item{n_threads}{Number of threads to use.}

\item{block_size}{Number of items to generate neighbors for in each
multi-threaded batch. Reducing this number will increase the frequency
with which R will check for cancellation, and if \code{verbose = TRUE},
the frequency with which progress will be logged to the console. This value
should not be set too low (and not lower than \code{grain_size}), or the
overhead of cancellation checking and other multi-threaded house keeping
will reduce the efficiency of the parallel computation. Ignored if
\code{n_threads < 1}.}

\item{grain_size}{Minimum batch size for multithreading. If the number of
items to process in a thread falls below this number, then no threads will
be used. Ignored if \code{n_threads < 1}.}

\item{verbose}{If \code{TRUE}, log information to the console.}
}
\value{
a list containing:
\itemize{
  \item \code{idx} an n by k matrix containing the nearest neighbor
  indices.
  \item \code{dist} an n by k matrix containing the nearest neighbor
   distances.
}
}
\description{
Randomly select nearest neighbors.
}
\examples{
# Find 4 random neighbors and calculate their Euclidean distance
# If you pass a data frame, non-numeric columns are removed
iris_nn <- random_knn(iris, k = 4, metric = "euclidean")

# Manhattan (l1) distance
iris_nn <- random_knn(iris, k = 4, metric = "manhattan")

# Multi-threading: you can choose the number of threads to use: in real
# usage, you will want to set n_threads to at least 2
iris_nn <- random_knn(iris, k = 4, metric = "manhattan", n_threads = 1)

# Use verbose flag to see information about progress
iris_nn <- random_knn(iris, k = 4, metric = "euclidean", verbose = TRUE)

# These results can be improved by nearest neighbors descent. You don't need
# to specify k here because this is worked out from the initial input
iris_nn <- nnd_knn(iris, init = iris_nn, metric = "euclidean", verbose = TRUE)
}
