% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rnndescent.R
\name{random_knn_query}
\alias{random_knn_query}
\title{Nearest Neighbors Query by Random Selection}
\usage{
random_knn_query(
  query,
  reference,
  k,
  metric = "euclidean",
  use_alt_metric = TRUE,
  order_by_distance = TRUE,
  n_threads = 0,
  verbose = FALSE
)
}
\arguments{
\item{query}{Matrix of \code{n} query items.}

\item{reference}{Matrix of \code{m} reference items. The nearest neighbors to the
queries are randomly selected from this data.}

\item{k}{Number of nearest neighbors to return.}

\item{metric}{Type of distance calculation to use. One of \code{"euclidean"},
\code{"l2sqr"} (squared Euclidean), \code{"cosine"}, \code{"manhattan"}, \code{"correlation"}
(1 minus the Pearson correlation), \code{"hamming"} or \code{"bhamming"} (hamming
on binary data with bitset internal memory optimization).}

\item{use_alt_metric}{If \code{TRUE}, use faster metrics that maintain the
ordering of distances internally (e.g. squared Euclidean distances if using
\code{metric = "euclidean"}), then apply a correction at the end. Probably
the only reason to set this to \code{FALSE} is if you suspect that some
sort of numeric issue is occurring with your data in the alternative code
path.}

\item{order_by_distance}{If \code{TRUE} (the default), then results for each
item are returned by increasing distance. If you don't need the results
sorted, e.g. you are going to pass the results as initialization to another
routine like \code{\link[=graph_knn_query]{graph_knn_query()}}, set this to \code{FALSE} to save a
small amount of computational time.}

\item{n_threads}{Number of threads to use.}

\item{verbose}{If \code{TRUE}, log information to the console.}
}
\value{
an approximate nearest neighbor graph as a list containing:
\itemize{
\item \code{idx} an n by k matrix containing the nearest neighbor indices.
\item \code{dist} an n by k matrix containing the nearest neighbor distances.
}
}
\description{
Nearest Neighbors Query by Random Selection
}
\examples{
# 100 reference iris items
iris_ref <- iris[iris$Species \%in\% c("setosa", "versicolor"), ]

# 50 query items
iris_query <- iris[iris$Species == "versicolor", ]

# For each item in iris_query find 4 random neighbors in iris_ref
# If you pass a data frame, non-numeric columns are removed
# set verbose = TRUE to get details on the progress being made
iris_query_random_nbrs <- random_knn_query(iris_query,
  reference = iris_ref,
  k = 4, metric = "euclidean", verbose = TRUE
)

# Manhattan (l1) distance
iris_query_random_nbrs <- random_knn_query(iris_query,
  reference = iris_ref,
  k = 4, metric = "manhattan"
)
}
