<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="rnndescent">
<title>rnndescent • rnndescent</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="rnndescent">
<meta property="og:description" content="rnndescent">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">rnndescent</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.12</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/rnndescent.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav"></ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>rnndescent</h1>
            
      
      
      <div class="d-none name"><code>rnndescent.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://jlmelville.github.io/rnndescent/">rnndescent</a></span><span class="op">)</span></span></code></pre></div>
<p>Nearest Neighbor Descent (NND) <span class="citation">(Dong, Moses,
and Li 2011)</span> is affected by hubness <span class="citation">(Bratić et al. 2019)</span>: this is when some items in
a dataset appear as a near neighbor of other points very frequently.
This can result in reduced accuracy of the approximate nearest neighbor
graph produced by NND and may be an intrinsic problem in high
dimensional datasets (although see <span class="citation">(Low et al.
2013)</span> for a dissenting view).</p>
<p>In this vignette we will use synthetic data to explore the issue, and
use the k-occurrences of a neighbor graph to identify when NND is at
risk of producing less accurate results. We will also look at some ways
to ameliorate the effects of hubness.</p>
<p>First, to control the pseudo-random number generation:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span></code></pre></div>
<p>Now let’s create some Gaussian data to test with. First, a
low-dimensional example:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_points</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">low_dim</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">g2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n_points</span> <span class="op">*</span> <span class="va">low_dim</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">low_dim</span><span class="op">)</span></span></code></pre></div>
<p>In this vignette, we are interested in the 15 nearest neighbors. To
get the exact nearest neighbors, we use the <code>brute_force_knn</code>
function with <code>k = 15</code>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g2d_nnbf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brute_force_knn.html">brute_force_knn</a></span><span class="op">(</span><span class="va">g2d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span></code></pre></div>
<p>This will act as our “ground truth” and we will compare how well NND
does. To use NND to find the approximate nearest neighbors, we use the
<code>nnd_knn</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g2d_nnd</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g2d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span></code></pre></div>
<p>To calculate the accuracy of NND we will produce a vector where each
element contains the accuracy with which the exact 15-nearest neighbors
were reproduced for each item in the data: <code>0</code> means that
none of the exact 15-nearest neighbors were in the list of 15-nearest
neighbors that NND found, and <code>1</code> means they all were.</p>
<p>To get the vector of accuracies, here is the
<code>nn_accuracyv</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nn_accuracyv</span> <span class="op">&lt;-</span></span>
<span>  <span class="kw">function</span><span class="op">(</span><span class="va">idx</span>,</span>
<span>           <span class="va">ref_idx</span>,</span>
<span>           <span class="va">k</span> <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>           <span class="va">include_self</span> <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>           <span class="va">verbose</span> <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">is.list</a></span><span class="op">(</span><span class="va">idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">idx</span> <span class="op">&lt;-</span> <span class="va">idx</span><span class="op">$</span><span class="va">idx</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">is.list</a></span><span class="op">(</span><span class="va">ref_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">ref_idx</span> <span class="op">&lt;-</span> <span class="va">ref_idx</span><span class="op">$</span><span class="va">idx</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NULL.html" class="external-link">is.null</a></span><span class="op">(</span><span class="va">k</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">k</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">idx</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">ref_idx</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">ref_idx</span><span class="op">)</span> <span class="op">&lt;</span> <span class="va">k</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Not enough columns in ref_idx for k = "</span>, <span class="va">k</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">idx</span><span class="op">)</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">ref_idx</span><span class="op">)</span> <span class="op">!=</span> <span class="va">n</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Not enough rows in ref_idx"</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="va">nbr_start</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span>    <span class="va">nbr_end</span> <span class="op">&lt;-</span> <span class="va">k</span></span>
<span></span>
<span>    <span class="va">ref_start</span> <span class="op">&lt;-</span> <span class="va">nbr_start</span></span>
<span>    <span class="va">ref_end</span> <span class="op">&lt;-</span> <span class="va">nbr_end</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">include_self</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">ref_start</span> <span class="op">&lt;-</span> <span class="va">ref_start</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>      <span class="kw">if</span> <span class="op">(</span><span class="va">nbr_end</span> <span class="op">&lt;</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">ref_idx</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">ref_end</span> <span class="op">&lt;-</span> <span class="va">ref_end</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>      <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>        <span class="va">nbr_end</span> <span class="op">&lt;-</span> <span class="va">nbr_end</span> <span class="op">-</span> <span class="fl">1</span></span>
<span>      <span class="op">}</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="va">nbr_range</span> <span class="op">&lt;-</span> <span class="va">nbr_start</span><span class="op">:</span><span class="va">nbr_end</span></span>
<span>    <span class="va">ref_range</span> <span class="op">&lt;-</span> <span class="va">ref_start</span><span class="op">:</span><span class="va">ref_end</span></span>
<span></span>
<span>    <span class="va">total_intersect</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, times <span class="op">=</span> <span class="va">n</span><span class="op">)</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">total_intersect</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sets.html" class="external-link">intersect</a></span><span class="op">(</span><span class="va">idx</span><span class="op">[</span><span class="va">i</span>, <span class="va">nbr_range</span><span class="op">]</span>, <span class="va">ref_idx</span><span class="op">[</span><span class="va">i</span>, <span class="va">ref_range</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="va">total_intersect</span> <span class="op">/</span> <span class="va">k</span></span>
<span>  <span class="op">}</span></span></code></pre></div>
<p><code>nn_accuracy</code> is the average accuracy over the whole
dataset:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nn_accuracy</span> <span class="op">&lt;-</span></span>
<span>  <span class="kw">function</span><span class="op">(</span><span class="va">idx</span>,</span>
<span>           <span class="va">ref_idx</span>,</span>
<span>           <span class="va">k</span> <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>           <span class="va">include_self</span> <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>           <span class="va">verbose</span> <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">vec</span> <span class="op">&lt;-</span> <span class="fu">nn_accuracyv</span><span class="op">(</span><span class="va">idx</span>, <span class="va">ref_idx</span>, <span class="va">k</span>, <span class="va">include_self</span>, <span class="va">verbose</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">vec</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span></code></pre></div>
<p>With low-dimensional data, nearest neighbor descent does very
well:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g2d_nnbf</span>, <span class="va">g2d_nnd</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>Now let’s see what happens with a high-dimensional (1000
features):</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hi_dim</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">g1000d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n_points</span> <span class="op">*</span> <span class="va">hi_dim</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">hi_dim</span><span class="op">)</span></span></code></pre></div>
<p>Again we will use brute force to generate the true nearest
neighbors.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnbf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/brute_force_knn.html">brute_force_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span></code></pre></div>
<p>Let’s do NND on the high dimensional data…</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span></code></pre></div>
<p>…and see how well it does:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.7856</span></span></code></pre></div>
<p>Still OK, but not as good as we might like.</p>
<div class="section level2">
<h2 id="comparing-low--and-high-dimensional-nearest-neighbors">Comparing Low- and High-Dimensional Nearest Neighbors<a class="anchor" aria-label="anchor" href="#comparing-low--and-high-dimensional-nearest-neighbors"></a>
</h2>
<p>Let’s look at the distribution of nearest neighbor distances in high
and low dimensions (for easier comparison, I have normalized them with
respect to the largest distance)</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g2d_nnbf</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_nnbf</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>, xlab <span class="op">=</span> <span class="st">"distances"</span>, main <span class="op">=</span> <span class="st">"2D 15-NN"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/NN%20distances%20distribution-1.png" width="700"></p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_nnbf</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nnbf</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>, xlab <span class="op">=</span> <span class="st">"distances"</span>, main <span class="op">=</span> <span class="st">"1000D 15-NN"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/NN%20distances%20distribution-2.png" width="700"></p>
<p>Compared to low dimensional data, we can see that the high
dimensional distances are distributed around a higher distance as well
as more symmetric in their distribution.</p>
<p>Here are the distribution of the neighbor distances in the
high-dimensional case for the neighbors found by NND:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_nnd</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nnd</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"distances"</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D 15-NND"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/NND%20distances%20distribution-1.png" width="700"></p>
<p>Pretty much indistinguishable from the exact results, so it seems
like there isn’t an obvious diagnostic from the distances
themselves.</p>
<p>Is the distribution of the errors in the NND results uniform or are
some items neighborhoods noticeably better predicted than others? This
function will calculate a vector of the relative RMS error between two
sets of neighbors in terms of distances:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nn_rrmsev</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">nn</span>, <span class="va">ref</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">ref</span><span class="op">$</span><span class="va">dist</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="op">(</span><span class="va">nn</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="va">ref</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span> <span class="op">/</span> <span class="va">n</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span> <span class="op">/</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">ref</span><span class="op">$</span><span class="va">dist</span><span class="op">[</span>, <span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">^</span><span class="fl">2</span>, <span class="fl">1</span>, <span class="va">sum</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We don’t include the first nearest neighbor distances, as these are
invariably the self distances which leads to an uninteresting number of
zero error results. This measure of error is a bit less strict than
<code>nn_accuracyv</code> as a neighbor that is outside the true kNN,
but which has a comparable distance, will be penalized a less harshly
than a more distant point.</p>
<p>Here’s a histogram of RRMS distance errors:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_rrmse</span> <span class="op">&lt;-</span> <span class="fu">nn_rrmsev</span><span class="op">(</span><span class="va">g1000d_nnd</span>, <span class="va">g1000d_nnbf</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_rrmse</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D distance error"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"Relative RMS error"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/histogram%20of%20distance%20difference-1.png" width="700"></p>
<p>None of the relative errors are actually that large, so if you only
care about the value of kth nearest neighbor distances, then even in the
1000D case, we still get decent results in this case. We can also see
that there is a clear distribution of errors, where an appreciable
number of items have zero RRMS distance errors, but there a few items
which have the largest error.</p>
<p>Here is a histograms of the accuracies:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_acc</span> <span class="op">&lt;-</span> <span class="fu">nn_accuracyv</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_nnd_acc</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D accuracy"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"accuracy"</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/hist%201000D-1.png" width="700"></p>
<p>This shows a similar pattern: some items have very high accuracy and
some have noticeably worse accuracy than average. For completeness, here
is the relationship between accuracy and RRMSE:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span></span>
<span>  <span class="va">g1000d_nnd_acc</span>,</span>
<span>  <span class="va">g1000d_rrmse</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"RRMSE vs accuracy"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"accuracy"</span>,</span>
<span>  ylab <span class="op">=</span> <span class="st">"RRMSE"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/rrmse%20vs%20acc-1.png" width="700"></p>
<p>Nothing very surprising here: there’s a fairly consistent spread of
RRMSE for a given accuracy.</p>
<p>So whether you use an error in the distance or accuracy to measure
how well the approximate nearest neighbors method is working, at least
in this case, a high dimensional dataset affects some items more than
others.</p>
</div>
<div class="section level2">
<h2 id="detecting-hubness">Detecting Hubness<a class="anchor" aria-label="anchor" href="#detecting-hubness"></a>
</h2>
<p><span class="citation">(Radovanovic, Nanopoulos, and Ivanovic
2010)</span> discusses a technique for detecting hubness: look for items
that appear very frequently in the k-nearest neighbor graph. The
<code>k_occur</code> function counts “k-occurrences” of each item in a
dataset, i.e. a count of the number of times an item appears in the
k-nearest neighbor graph. You can also see it as reversing the direction
of the edges in the k-nearest neighbor graph and then counting the
in-degree of each item.</p>
<p>If the distribution of neighbors was entirely uniform we would expect
to see each item appear <span class="math inline">\(k\)</span> times. If
there are hubs then the k-occurrence could get as large as the size of
the dataset, <span class="math inline">\(N\)</span>. An item which
appears in the neighbor graph fewer than <span class="math inline">\(k\)</span> times could be termed an “antihub”. Our
definition of a neighbor of an item always includes the item itself, so
we would expect the minimum <span class="math inline">\(k\)</span>-occurrence to be <span class="math inline">\(1\)</span>.</p>
<p>Also, because there are always only <span class="math inline">\(Nk\)</span> edges in a <span class="math inline">\(k\)</span>-nearest neighbor graph, if an item
appears more than the expected amount this implies that other items must
be under-represented. Practically speaking, there are always going to be
items with a larger <span class="math inline">\(k\)</span>-occurrence
than expected and hence some with a lower <span class="math inline">\(k\)</span>-occurrence, so hubness or anti-hubness
is more a case of deciding on a cut-off after which the presence of an
item with a lot of neighbors starts causing you problems, which is going
to be dependent on what you are planning to do with the neighbor graph
(and probably the number of neighbors you want).</p>
<div class="section level3">
<h3 id="k-occurrence-in-the-2d-case">k-occurrence in the 2D case<a class="anchor" aria-label="anchor" href="#k-occurrence-in-the-2d-case"></a>
</h3>
<p>First, let’s look at the 2D case using the exact k-nearest
neighbors:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g2d_bfko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g2d_nnbf</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;       1      13      15      15      17      24</span></span></code></pre></div>
<p>The mean average of the <span class="math inline">\(k\)</span>-occurrence is never helpful: as noted
above there are always <span class="math inline">\(Nk\)</span> edges in
the neighbor graph, so the mean <span class="math inline">\(k\)</span>-occurrence is always <span class="math inline">\(k\)</span>. However the other descriptions of the
distribution are informative. The median <span class="math inline">\(k\)</span>-occurrence is also <code>15</code>,
which is a good sign, and the values at 25% and 75% aren’t too different
other. The maximum <span class="math inline">\(k\)</span>-occurrence is
less than <span class="math inline">\(2k\)</span>. The minimum value is
<code>1</code> which means there are anti-hubs in the dataset, but:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g2d_bfko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<p>there is only one anti-hub in this dataset. Here’s a histogram of the
k-occurrences:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g2d_bfko</span>, main <span class="op">=</span> <span class="st">"2D 15-NN"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/2D%20k-occurrence%20histogram-1.png" width="700"></p>
<p>This unremarkable-looking distribution is a visual indication of a
dataset without a lot of hubness and anti-hubs lurking to cause problems
for nearest neighbor descent.</p>
</div>
<div class="section level3">
<h3 id="k-occurrence-in-the-1000d-case">k-occurrence in the 1000D case<a class="anchor" aria-label="anchor" href="#k-occurrence-in-the-1000d-case"></a>
</h3>
<p>Here’s what the k-occurrence histogram looks like for the high
dimensional case:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_bfko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000d_nnbf</span><span class="op">$</span><span class="va">idx</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_bfko</span>, main <span class="op">=</span> <span class="st">"1000D 15-NN"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/1000D%20k-occurrences-1.png" width="700"></p>
<p>The differences are pretty stark. The first thing to notice is the
x-axis. In the 2D case, the maximum k-occurrence was ~20. For the 1000D
we are looking at ~300. It’s hard to see any details, so let’s zoom in
on the same region as the 2D case by clipping any k-occurrence larger
than the largest 2D k-occurrence:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmin</a></span><span class="op">(</span><span class="va">g1000d_bfko</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D 15-NN zoomed"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"k-occurrences"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/zoomed%20k-occurrences-1.png" width="700"></p>
<p>It’s a very different distribution to the 2D case: we have a large
number of anti-hubs and a noticeable number of hubs. There’s certainly
no peak at a k-occurrence of 15. Comparing the numerical summary with
the 2D case is instructive:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_bfko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;    1.00    2.00    5.00   15.00   14.25  346.00</span></span></code></pre></div>
<p>Again, here’s a good reminder that the mean k-occurrence is of no
value. The median k-occurrence immediately communicates the difference
between the 2D case. We can also see that the maximum k-occurrence means
that there is one point which is considered a close neighbor of over one
third of the dataset.</p>
<p>How many anti-hubs are there?</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_bfko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 221</span></span></code></pre></div>
<p>A quarter of the dataset does not appear as a neighbor of any other
point. This has serious implications for using a neighbor graph for
certain purposes: you cannot reach a quarter of the dataset by starting
at an arbitrary point in the graph and following neighbors.</p>
<p>This also might point to why nearest neighbor descent has trouble
with this high dimensional case: if we rely on points turning up as a
neighbors of other points in order to introduce them to potential
neighbors, the fact that so many of the points in this dataset aren’t
anyone’s actual neighbors would suggest they are unlikely to get
involved in the local join procedure as much as other points.</p>
</div>
<div class="section level3">
<h3 id="k-occurrence-as-a-diagnostic-of-nnd-failure">k-occurrence as a diagnostic of NND failure<a class="anchor" aria-label="anchor" href="#k-occurrence-as-a-diagnostic-of-nnd-failure"></a>
</h3>
<p>We have now shown that we can use k-occurrences on the exact nearest
neighbors of low and high dimensional data to detect the existence of
hubs, which in turn might lead us to suspect that the approximate
nearest neighbors found by nearest neighbor descent may not be very
accurate. But that’s not a very useful diagnostic because if we have the
exact neighbors we don’t need to run NND in the first place. But even if
the approximate nearest neighbor graph produced by NND isn’t highly
accurate, does it still show similar characteristics of hubness?</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nndko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000d_nnd</span><span class="op">$</span><span class="va">idx</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, main <span class="op">=</span> <span class="st">"1000D 15-NND"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/1000D%20NND%20k-occurences-1.png" width="700"></p>
<p>That seems similar to the true results, and zooming in like we did
with the exact results:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmin</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D 15-NND zoomed"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"k-occurrences"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/zoomed%20NND%20k-occurrences-1.png" width="700"></p>
<p>Visually this looks a lot like the distribution of the exact results.
Next, the numerical summary:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_nndko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;       1       2       4      15      12     407</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_nndko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 249</span></span></code></pre></div>
<p>Quantitatively, this also tracks the exact results: the median
k-occurrence is much smaller than <span class="math inline">\(k\)</span>, there is a hub with a very large
number of neighbors (larger than in the exact case but to a similar
degree) and a similar number of anti-hubs.</p>
<p>So this suggests a way to diagnose if the nearest neighbor descent
routine may have low accuracy: look at the distribution of the
k-occurrences of the resulting approximate nearest neighbor graph (or
even just the maximum value). A value that is <span class="math inline">\(\gg k\)</span> may mean a reduced accuracy. Of
course, this isn’t foolproof, because even if NND did a perfect job then
we would still get these sorts of values, but it’s a starting point.</p>
<p>Taking the distribution of k-occurrences as a whole, the approximate
results seem to track the exact results fairly well, but as we have
seen, the errors in the approximate results are not uniformly
distributed across the data. So let’s see how well the NND k-occurrences
“predict” the exact results:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"approximate"</span>, ylab <span class="op">=</span> <span class="st">"exact"</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D k-occ"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>a <span class="op">=</span> <span class="fl">0</span>, b <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/approximate%20vs%20true%201000D%20k-occurrence-1.png" width="700"></p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span>, method <span class="op">=</span> <span class="st">"pearson"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9945236</span></span></code></pre></div>
<p>The overall relationship seems strong. The line on the plot is x=y,
so we can see that at high values of the k-occurrence the NND results
tend to over-estimate the k-occurrence, but these are such large values
that this hardly matters, and there is no ambiguity over which nodes are
most hub-like.</p>
<p>Zooming in to lower values of the k-occurrence:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"approximate"</span>, ylab <span class="op">=</span> <span class="st">"exact"</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D low k-occ"</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>a <span class="op">=</span> <span class="fl">0</span>, b <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/zoomed%20approximate%20vs%20true%201000D%20k-occurrence-1.png" width="700"></p>
<p>here it seems that there is a tendency to over-estimate the
k-occurrence. Anti-hubs are also not perfectly identified, but there are
no true anti-hubs which appear more than a small number of times in the
approximate neighbor graph.</p>
</div>
<div class="section level3">
<h3 id="detecting-poorly-predicted-neighbors">Detecting Poorly Predicted Neighbors<a class="anchor" aria-label="anchor" href="#detecting-poorly-predicted-neighbors"></a>
</h3>
<p>We’ve seen that some objects have their neighbors predicted better
than others. Based on everything we’ve seen so far about k-occurrences
and NND, it would be reasonable to wonder: are the items in a dataset
with poorly predicted neighbors the anti-hubs (predicted or exact)? This
would at least give us some way of detecting those items that were
likely to have low accuracy neighborhoods: perhaps they could be treated
specially (or by some other algorithm).</p>
<p>Here’s a plot of the accuracy against the k-occurrences of the NND
neighbors:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_nnd_acc</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"NND k-occ"</span>, ylab <span class="op">=</span> <span class="st">"accuracy"</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span>, <span class="va">g1000d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D acc vs NND k-occ"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/predicting%20accuracy%20with%20NND%20k-occurrence-1.png" width="700"></p>
<p>So the answer to the question is “not really”, but there <em>is</em>
a trend. The empty space in the lower right of the plot indicates that
items with a large k-occurrence (hubs) are very well predicted. And
above a k-occurrence of 150, we are guaranteed to perfectly predict the
neighborhood of an item. However, at the other end of the k-occurrence
spectrum, we can see that while the lower bound on the predicted
accuracy does plummet as the k-occurrence is reduced, some anti-hubs
actually do have their neighborhoods very accurately predicted too.</p>
<p>Unfortunately this means that k-occurrence is a bit too rough to use
to predict poorly-predicted items. Let’s say that we wanted to get all
the items where the neighborhood was less than 90% accurate:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_nnd_acc</span> <span class="op">&lt;</span> <span class="fl">0.9</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 768</span></span></code></pre></div>
<p>That’s already quite a lot of items: about three-quarters of the
entire dataset. What is the largest k-occurrence for an item in the
dataset with that accuracy threshold?</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span><span class="op">[</span><span class="va">g1000d_nnd_acc</span> <span class="op">&lt;</span> <span class="fl">0.9</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 66</span></span></code></pre></div>
<p>Then, to guarantee that we had found all the items that might be
poorly predicted, we would need to filter out every item that had a
k-occurrence smaller than that value, even though we know that some of
them are well-predicted:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_nndko</span> <span class="op">&lt;=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span><span class="op">[</span><span class="va">g1000d_nnd_acc</span> <span class="op">&lt;</span> <span class="fl">0.9</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 949</span></span></code></pre></div>
<p>That’s most of the dataset. If we dropped the threshold to 80
accuracy, does it help?</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_nndko</span> <span class="op">&lt;=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g1000d_nndko</span><span class="op">[</span><span class="va">g1000d_nnd_acc</span> <span class="op">&lt;</span> <span class="fl">0.8</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 867</span></span></code></pre></div>
<p>A bit, but it’s still a substantial majority of the dataset. So
whatever we decided to do with these items we wouldn’t be saving a huge
amount of effort.</p>
<p>So much for that idea. What this suggests is not that we
<em>can’t</em> improve results here, just that the effort of identifying
individual points to filter out, treat differently and then merge back
into the final neighbor graph means that just reprocessing the entire
dataset in a different way is likely to be a competitive solution.</p>
</div>
<div class="section level3">
<h3 id="detecting-problems-early">Detecting Problems Early<a class="anchor" aria-label="anchor" href="#detecting-problems-early"></a>
</h3>
<p>Back to looking at the k-occurrence distribution as a whole: we can
see that the converged NND results, despite not being 100% accurate do a
good job at expressing the hubness of the underlying data. How converged
do the results need to be? What if we think of NND as a tool for
identifying hubness in datasets as a whole rather than for accurate
approximate nearest neighbor graphs? Could a much less unconverged NND
graph, while obviously being even less accurate, still correctly
identify a dataset as having hubs?</p>
<p>To test this, let’s run the NND method for only one iteration and get
the k-occurrences that result:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_iter1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span>, n_iters <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">g1000d_nndkoi1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000d_nnd_iter1</span><span class="op">$</span><span class="va">idx</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span></code></pre></div>
<p>How accurate are these results?</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_iter1</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.3123333</span></span></code></pre></div>
<p>Ok, I think we can all agree we do <em>not</em> have an accurate
neighbor graph. But let’s take a look at the k-occurrence
distribution:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_nndkoi1</span>, main <span class="op">=</span> <span class="st">"1000D 15-NND (1 iter)"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/unconverged%20ko%20distribution-1.png" width="700"></p>
<p>Looking familiar. Zooming in…</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmin</a></span><span class="op">(</span><span class="va">g1000d_nndkoi1</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">g2d_bfko</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D 15-NND (1 iter, zoomed)"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"k-occurrences"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/unconverged%20ko%20distribution%20zoomed-1.png" width="700"></p>
<p>The distribution is at least similar to the converged version. Taking
a look at some numbers:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_nndkoi1</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;       1       2       7      15      17     191</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_nndkoi1</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 155</span></span></code></pre></div>
<p>Compared to the converged (or exact) distribution, the median
k-occurrence is not as low, the object with the largest k-occurrence,
while large (<span class="math inline">\(&gt; 10k\)</span>, which seems
like a good threshold to be concerned about the presence of hubs) is not
as large, and there are fewer objects which are anti-hubs.</p>
<p>At least for this dataset, hubness can be qualitatively detected with
even a very inaccurate neighbor graph. What about datasets that don’t
contain hubs? Let’s just check that what we are seeing is not an
artifact of unconverged nearest neighbor descent, by running through the
same procedure with the 2D dataset:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g2d_nnd_iter1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g2d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span>, n_iters <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">g2d_nndkoi1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g2d_nnd_iter1</span><span class="op">$</span><span class="va">idx</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g2d_nndkoi1</span>, main <span class="op">=</span> <span class="st">"2D 15-NND (1 iter)"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/unconverged%202D%20NND-1.png" width="700"></p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g2d_nndkoi1</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;       1      11      15      15      19      33</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g2d_nndkoi1</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 4</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g2d_nnbf</span>, <span class="va">g2d_nnd_iter1</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.3492667</span></span></code></pre></div>
<p>We can see that the neighbor graph is also not very accurate after 1
iteration in the 2D case, but the distribution of k-occurrences also
qualitatively resembles the exact result. This time, compared to the
exact results there are slightly more anti-hubs and the maximum
k-occurrence is increased, so the trends are slightly reversed compared
to the 1000D data.</p>
<p>For at least qualitative identification of hubness, then, one
iteration of nearest neighbor descent might be enough.</p>
</div>
</div>
<div class="section level2">
<h2 id="improving-accuracy">Improving accuracy<a class="anchor" aria-label="anchor" href="#improving-accuracy"></a>
</h2>
<p>We know that nearest neighbor descent (at least with typical
settings) may not give highly accurate results in high dimensions. And
with the help of k-occurrences, we can even detect that it might be
happening. But what can we do about it?</p>
<div class="section level3">
<h3 id="use-more-neighbors">Use More Neighbors<a class="anchor" aria-label="anchor" href="#use-more-neighbors"></a>
</h3>
<p>One simple (slightly expensive) way is to keep more neighbors in the
calculation. For example, double the number of neighbors to
<code>30</code>, then get the top-15 accuracy:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_k30</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">30</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_k30</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9736</span></span></code></pre></div>
<p>That’s a big improvement, but increasing <code>k</code> in this way
can be quite expensive in terms of run time.</p>
</div>
<div class="section level3">
<h3 id="merging-multiple-independent-results">Merging Multiple Independent Results<a class="anchor" aria-label="anchor" href="#merging-multiple-independent-results"></a>
</h3>
<p>What about taking advantage of the stochastic nature of the
algorithm? If the results are sufficiently diverse between runs of NND,
then we could generate two graphs from two separate runs, and then merge
the results.</p>
<p>Let’s repeat NND and see what the accuracy of this new result is
like.</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_rep</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_rep</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.7818</span></span></code></pre></div>
<p>That’s similar to the first run. That’s re-assuring in the sense that
the variance of the accuracy doesn’t seem to be that high between one
run to the next. But hopefully that doesn’t also mean that NND is
producing a very similar neighbor graph each time, in which case merging
them won’t be very helpful. Time to find out:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_merge</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/merge_knn.html">merge_knn</a></span><span class="op">(</span><span class="va">g1000d_nnd</span>, <span class="va">g1000d_nnd_rep</span><span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_merge</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.908</span></span></code></pre></div>
<p>That’s a big improvement. So it does seem like there is some
diversity in the results.</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_rep_acc</span> <span class="op">&lt;-</span> <span class="fu">nn_accuracyv</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_rep</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span></span>
<span>  <span class="va">g1000d_nnd_acc</span>,</span>
<span>  <span class="va">g1000d_nnd_rep_acc</span>,</span>
<span>  main <span class="op">=</span> <span class="st">"1000D NND accuracy comparison"</span>,</span>
<span>  xlab <span class="op">=</span> <span class="st">"accuracy run 1"</span>,</span>
<span>  ylab <span class="op">=</span> <span class="st">"accuracy run 2"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/NND%20100D%20compare%20accuracy-1.png" width="700"></p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">g1000d_nnd_acc</span>, <span class="va">g1000d_nnd_rep_acc</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.467723</span></span></code></pre></div>
<p>Despite the similar overall accuracies, there’s quite a large
variance between runs in terms of which items have accurate
neighborhoods.</p>
<p>So there might be some scope for improving the results by merging
different runs, especially if you can run the individual NND routines in
parallel.</p>
</div>
<div class="section level3">
<h3 id="using-a-search-graph">Using a Search Graph<a class="anchor" aria-label="anchor" href="#using-a-search-graph"></a>
</h3>
<p>Practically, the simplest way to improve results with
<code>rnndescent</code> is to convert the neighbor graph into a search
graph, and then query it with the original data.</p>
<p>First, the preparation step:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_search_graph</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/prepare_search_graph.html">prepare_search_graph</a></span><span class="op">(</span></span>
<span>    data <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    graph <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    diversify_prob <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    pruning_degree_multiplier <span class="op">=</span> <span class="fl">1.5</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>This augments the neighbor graph with the reversed edges of the
neighbor graph, so that if <span class="math inline">\(i\)</span> is one
of the nearest neighbors of <span class="math inline">\(j\)</span>, we
guarantee that <span class="math inline">\(j\)</span> is also considered
a near neighbor <span class="math inline">\(i\)</span>. This ameliorates
the issue of anti-hubs because all <span class="math inline">\(k\)</span> neighbors of an anti-hub now have it in
their neighbor list.</p>
<p>The downside of including all reversed edges in the neighbor graph is
that the neighbor list of a hub is now going to be very large as it
consists of the <span class="math inline">\(k\)</span> nearest neighbors
of the hub and then all the items that consider the hub a near neighbor,
which by definition is a lot. This can make the search graph
inefficient, as a disproportionate amount of time will be spent
searching neighbors of the hub. The <code>diversify_prob</code> and
<code>pruning_degree_multiplier</code> parameters are used to reduce
back down the out-degree of each node (the number of out-going edges).
This results in objects with a varying number of neighbors, in this case
to a maximum of 22. This is about 50% larger than <code>k = 15</code> to
account for the introduction of the reverse edges. Anti-hubs can be
reintroduced due to the edge reduction, but hopefully the distribution
of edges is a bit more equitable.</p>
<p>Here is a summary and histogram of the k-occurrences of the search
graph:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_sgko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000d_search_graph</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_sgko</span>, main <span class="op">=</span> <span class="st">"search graph k-occurrences"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/histogram%20of%20k-occurrences%20of%20search%20graph-1.png" width="700"></p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_sgko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;   1.000   2.250   4.000   7.629   9.000 106.000</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_sgko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 113</span></span></code></pre></div>
<p>This is not <em>quite</em> as skewed as the neighbor graph, but there
is still a lot of room for improvement.</p>
<p>At any rate, with the search graph in hand, we can now search it
using our original data as a query:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_search</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>    query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference_graph <span class="op">=</span> <span class="va">g1000d_search_graph</span>,</span>
<span>    k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    init <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    epsilon <span class="op">=</span> <span class="fl">0.1</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>Are the results improved?</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_search</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9978667</span></span></code></pre></div>
<p>Yes, the accuracy is now nearly perfect. The disadvantages of the
search graph approach for building a neighbor graph is that it is less
efficient than NND: <code>graph_knn_query</code> must assume that the
<code>query</code> data is entirely different to the
<code>reference</code> data. The advantage is that we can make use of
reverse edges and, more importantly, back-tracking (controlled via the
<code>epsilon</code> parameter), which seems to make the difference in
this example.</p>
<p>The procedure above is the recommended practice of using
<code>graph_knn_query</code> with a search graph generated from the
neighbor graph. You are not required to use a search graph as the
argument to the <code>reference_graph</code> parameter. Here is the
back-tracking search using the neighbor graph directly and everything
else the same:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_search</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>    query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference_graph <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    init <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    epsilon <span class="op">=</span> <span class="fl">0.1</span></span>
<span>  <span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_search</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9850667</span></span></code></pre></div>
<p>Accuracies are nearly as good. You can save even more time by turning
off back-tracking (<code>epsilon = 0</code>):</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd_search0</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>    query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference_graph <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    init <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    epsilon <span class="op">=</span> <span class="fl">0</span></span>
<span>  <span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd_search0</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.827</span></span></code></pre></div>
<p>but accuracies are now noticeably less improved. Using the search
graph without back-tracking gives slightly better accuracies:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_search0</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>    query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    reference_graph <span class="op">=</span> <span class="va">g1000d_search_graph</span>,</span>
<span>    k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    init <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>    epsilon <span class="op">=</span> <span class="fl">0</span></span>
<span>  <span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_search0</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.8492667</span></span></code></pre></div>
<p>but it seems like some sort of back-tracking is to be recommended
with this approach.</p>
</div>
<div class="section level3">
<h3 id="local-scaling">Local Scaling<a class="anchor" aria-label="anchor" href="#local-scaling"></a>
</h3>
<p>In the context of spectral clustering, <span class="citation">(Zelnik-manor and Perona 2005)</span> suggested scaling
nearest neighbor distances to reflect the local statistics of the
neighborhoods. This would allow the idea of what a large and a short
distance was to vary depending on the local density around each point.
The scaling suggested was:</p>
<p><span class="math display">\[\hat{d}_{ij}^2 =
\frac{d_{ij}^2}{\sigma_i\sigma_j}\]</span></p>
<p>where <span class="math inline">\(\hat{d}_{ij}\)</span> is the scaled
distance between points <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, <span class="math inline">\(d_{ij}\)</span> is the original distance, and
<span class="math inline">\(\sigma_i\)</span> is the local scale
associated with point <span class="math inline">\(i\)</span>. To define
<span class="math inline">\(\sigma_i\)</span>, Zelnik-Manor and Perona
suggest using the distance to a nearest neighbor. In their paper they
got good results by using the distance to the seventh-nearest
neighbor.</p>
<p><span class="citation">(Schnitzer et al. 2012)</span> suggested using
<span class="math inline">\(\hat{d}_{ij}\)</span> instead of <span class="math inline">\(d_{ij}\)</span> in nearest neighbor calculations
as a way to reduce the effect of hubs. Because hubs have more neighbors,
the distance to a specific neighbor will be smaller relative to
non-hubs. Hence <span class="math inline">\(\sigma_i\)</span> will be
smaller for hubs, which will lead to larger <span class="math inline">\(\hat{d}_{ij}\)</span> compared to non-hubs.
Therefore using <span class="math inline">\(\hat{d}_{ij}\)</span> acts
to “penalize” hubs when competing with non-hubs to appear in a nearest
neighbor list.</p>
<p>A further modification suggested by Schnitzer and co-workers was to
use the average distance to multiple nearest neighbors to calculate
<span class="math inline">\(\sigma_i\)</span>, a technique used by <span class="citation">(Jegou, Harzallah, and Schmid 2007)</span>.</p>
<p>In the field of dimensionality reduction, generating a nearest
neighbor graph is a step for many methods. <span class="citation">(Wang
et al. 2021)</span> describe using local scaling as a post-processing
step with the following recipe:</p>
<ul>
<li>Find the <span class="math inline">\(k+50\)</span>th nearest
neighbors, where <span class="math inline">\(k\)</span> is the actual
number of neighbors you want (e.g. if you want to 15 neighbors per
point, find the 65 nearest neighbors).</li>
<li>Use the mean distance to the 4-6th nearest neighbors as <span class="math inline">\(\sigma_i\)</span>. Using this range was also
advocated in another dimensionality reduction method <span class="citation">(Amid and Warmuth 2019)</span>.</li>
<li>From the <span class="math inline">\(k+50\)</span> nearest
neighbors, find the <span class="math inline">\(k\)</span> neighbors
with the smallest locally scaled distances. These are the <span class="math inline">\(k\)</span> neighbors to use for downstream
processing.</li>
</ul>
<p>To do with our 1000D example, we first need to generate the
(approximate) 65-nearest neighbors:</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd65</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nnd_knn.html">nnd_knn</a></span><span class="op">(</span><span class="va">g1000d</span>, k <span class="op">=</span> <span class="fl">65</span>, metric <span class="op">=</span> <span class="st">"euclidean"</span><span class="op">)</span></span></code></pre></div>
<p>This is a noticeably slow step. Next, we use the
<code>local_scale_nn</code> function to extract a 15-neighbor
locally-scaled subset:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_nnd65ls15</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/local_scale_nn.html">local_scale_nn</a></span><span class="op">(</span><span class="va">g1000d_nnd65</span>, k <span class="op">=</span> <span class="fl">15</span>, k_scale <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>If you look at the distances in <code>g1000d_nnd65ls15</code> these
are the original unscaled distances, as found in
<code>g1000d_nnd65</code> (<span class="math inline">\(d_{ij}\)</span>).
The scaled distances <span class="math inline">\(\hat{d}_{ij}\)</span>
are used internally to select the 15 neighbors, but are not returned
from <code>local_scale_nn</code>.</p>
<p>How does local scaling affect the hubness of the resulting neighbor
graph?</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_lsko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000d_nnd65ls15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_lsko</span>, main <span class="op">=</span> <span class="st">"locally scaled k-occ"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/hubness%20of%20locally%20scaled%20nearest%20neighbor%20graph-1.png" width="700"></p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_lsko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;       1       6      11      15      19     116</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_lsko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 32</span></span></code></pre></div>
<p>This is a massive reduction in hubness over the 15NN graph, and
nearly as good as the search graph generated from the 15NN graph. Can we
see further improvements if we generate a search graph from the locally
scaled neighbors?</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000dls_search_graph</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="../reference/prepare_search_graph.html">prepare_search_graph</a></span><span class="op">(</span></span>
<span>    data <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>    graph <span class="op">=</span> <span class="va">g1000d_nnd65ls15</span>,</span>
<span>    metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    diversify_prob <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    pruning_degree_multiplier <span class="op">=</span> <span class="fl">1.5</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000d_lssgko</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/k_occur.html">k_occur</a></span><span class="op">(</span><span class="va">g1000dls_search_graph</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">g1000d_lssgko</span>, main <span class="op">=</span> <span class="st">"locally scaled search k-occ"</span>, xlab <span class="op">=</span> <span class="st">"k-occurrences"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rnndescent_files/figure-html/hubness%20of%20locally%20scaled%20search%20graph-1.png" width="700"></p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">g1000d_lssgko</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span></span>
<span><span class="co">#&gt;    1.00    6.00    9.00   10.39   13.00   82.00</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">g1000d_lssgko</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 17</span></span></code></pre></div>
<p>Here the hubness properties are further improved over using either
local scaling or creating a search graph separately. While this is
promising, does it translate into better search performance? Here are
the accuracy results using the locally scaled search graph without any
backtracking:</p>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000dls_search0nnd</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>        query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>        reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>        reference_graph <span class="op">=</span> <span class="va">g1000dls_search_graph</span>,</span>
<span>        k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>        metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>        init <span class="op">=</span> <span class="va">g1000d_nnd</span>,</span>
<span>        epsilon <span class="op">=</span> <span class="fl">0</span></span>
<span>    <span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000dls_search0nnd</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9410667</span></span></code></pre></div>
<p>Without having to do any back-tracking, we can get 94% accuracy, a
nearly 10% improvement compared to the search graph generated from the
15NN graph directly.</p>
<p>It’s worth noting here that we initialized the search using
<code>g1000d_nnd</code>, the 15NN results from running NND with
<code>k = 15</code>. This makes comparing the performance with the other
search graph fairer, but in reality we wouldn’t have that data to hand,
as we used <code>k = 65</code>. As noted in the ‘Use More Neighbors’
section above, we already know that using NND with an increased value of
<code>k</code> is going to result in a big improvement without bothering
with local scaling:</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000d_nnd65</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.9998</span></span></code></pre></div>
<p>Almost perfect. We also have the locally-scaled 15 nearest neighbor
graph we can use for initialization:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g1000dls_search0</span> <span class="op">&lt;-</span></span>
<span>    <span class="fu"><a href="../reference/graph_knn_query.html">graph_knn_query</a></span><span class="op">(</span></span>
<span>        query <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>        reference <span class="op">=</span> <span class="va">g1000d</span>,</span>
<span>        reference_graph <span class="op">=</span> <span class="va">g1000dls_search_graph</span>,</span>
<span>        k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>        metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>        init <span class="op">=</span> <span class="va">g1000d_nnd65ls15</span>,</span>
<span>        epsilon <span class="op">=</span> <span class="fl">0</span></span>
<span>    <span class="op">)</span></span>
<span><span class="fu">nn_accuracy</span><span class="op">(</span><span class="va">g1000d_nnbf</span>, <span class="va">g1000dls_search0</span>, k <span class="op">=</span> <span class="fl">15</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.8815333</span></span></code></pre></div>
<p>This is noticeably less good than initializing using the 15 NND
results, but it’s still the best non-back-tracking result. If we do set
<code>epsilon = 0.1</code>, then we get 100% accuracy using both the
neighbor graph and the search graph, but then again the other
non-locally scaled graphs are getting very close to that too.</p>
<p>The value of local scaling is probably not if you want to find an
accurate approximation to the nearest neighbors: using back-tracking
search with a search graph derived from the unscaled neighbor graph
directly is going to be less effort. However there may be cases where
the increased cost of building the <span class="math inline">\(k+50\)</span> nearest neighbor graph is not a big
problem, e.g. if you intend to build a graph once but search it many
times, then the search graph built from the locally scaled neighbor
graph is probably more efficient to traverse in cases where the unscaled
data suffers from hubs. Or the properties of the locally-scaled graph
may be more attractive for other uses e.g. dimensionality reduction
methods like those described by Wang and co-workers.</p>
</div>
</div>
<div class="section level2">
<h2 id="conclusions">Conclusions<a class="anchor" aria-label="anchor" href="#conclusions"></a>
</h2>
<ul>
<li>High dimensional data leads to hubs.</li>
<li>The “hubness” of an item in a dataset can be measured by the
k-occurrence in the corresponding nearest neighbor graph. The higher the
k-occurrence, the more of a hub it is.</li>
<li>The existence of a hubs implies the existence of “anti-hubs”,
i.e. items with a low k-occurrence. A small number of hubs can create a
disproportionately larger number of anti-hubs, with a larger value of
the k-occurrence creating more anti-hubs.</li>
<li>The accuracy of nearest neighbor descent is reduced by the presence
of hubs: specifically, the lower the k-occurrence of an item, the
greater the probability of a low accuracy of its nearest neighbors.</li>
<li>Accuracy of nearest neighbor descent can be improved by searching
for a larger number of neighbors and then truncating the result to the
desired size, at the cost of a longer run-time and memory usage.</li>
<li>Alternatively, you can run the the nearest neighbor descent multiple
times from different random starting points and merge the results.</li>
<li>More accurate and efficient results are obtained by converting the
nearest neighbor descent results into a search graph and then querying
the graph with the original data, using the nearest neighbor results for
initialization and a back-tracking search.</li>
<li>Local scaling can also reduce the effect of hubs and be combined
with a search graph, at the cost of a larger computational effort.</li>
</ul>
<p>If you are concerned with potential hubs interfering with the
accuracy of the neighbor graph, I suggest the following steps:</p>
<ol style="list-style-type: decimal">
<li>Generate a neighbor graph with <code>nnd_knn</code> and default
parameters.</li>
<li>Evaluate the hubness of the graph with <code>k_occur</code>.</li>
<li>If the maximum k-occurrence exceeds a threshold (maybe
<code>10 * k</code> is a good starting point), then use
<code>prepare_search_graph</code> and <code>graph_knn_query</code> with
back-tracking search (set <code>epsilon &gt; 0</code>) to refine the
results further.</li>
</ol>
<p>This should provide a robust approach to producing accurate
approximate nearest neighbors without spending time on unnecessary graph
search when the results are probably already quite good.</p>
<p>For more on the effect of hubness and nearest neighbors, and more
advanced attempts to fix the problem, see the work of Flexer and
co-workers <span class="citation">(Schnitzer et al. 2012; Flexer 2016;
Feldbauer and Flexer 2019; Feldbauer, Rattei, and Flexer 2019)</span>
and Radovanović and co-workers <span class="citation">(Radovanovic,
Nanopoulos, and Ivanovic 2010; Bratić et al. 2019)</span>.</p>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-DBLP:journals/corr/abs-1910-00204" class="csl-entry">
Amid, Ehsan, and Manfred K. Warmuth. 2019. <span>“TriMap: Large-Scale
Dimensionality Reduction Using Triplets.”</span> <em>CoRR</em>
abs/1910.00204. <a href="http://arxiv.org/abs/1910.00204" class="external-link">http://arxiv.org/abs/1910.00204</a>.
</div>
<div id="ref-bratic2019influence" class="csl-entry">
Bratić, Brankica, Michael E Houle, Vladimir Kurbalija, Vincent Oria, and
Miloš Radovanović. 2019. <span>“The Influence of Hubness on
NN-Descent.”</span> <em>International Journal on Artificial Intelligence
Tools</em> 28 (06): 1960002.
</div>
<div id="ref-dong2011efficient" class="csl-entry">
Dong, Wei, Charikar Moses, and Kai Li. 2011. <span>“Efficient k-Nearest
Neighbor Graph Construction for Generic Similarity Measures.”</span> In
<em>Proceedings of the 20th International Conference on World Wide
Web</em>, 577–86.
</div>
<div id="ref-feldbauer2019comprehensive" class="csl-entry">
Feldbauer, Roman, and Arthur Flexer. 2019. <span>“A Comprehensive
Empirical Comparison of Hubness Reduction in High-Dimensional
Spaces.”</span> <em>Knowledge and Information Systems</em> 59 (1):
137–66.
</div>
<div id="ref-feldbauer2019scikit" class="csl-entry">
Feldbauer, Roman, Thomas Rattei, and Arthur Flexer. 2019.
<span>“Scikit-Hubness: Hubness Reduction and Approximate Neighbor
Search.”</span> <em>arXiv Preprint arXiv:1912.00706</em>.
</div>
<div id="ref-flexer2016empirical" class="csl-entry">
Flexer, Arthur. 2016. <span>“An Empirical Analysis of Hubness in
Unsupervised Distance-Based Outlier Detection.”</span> In <em>2016 IEEE
16th International Conference on Data Mining Workshops (ICDMW)</em>,
716–23. IEEE.
</div>
<div id="ref-jegou2007contextual" class="csl-entry">
Jegou, Herve, Hedi Harzallah, and Cordelia Schmid. 2007. <span>“A
Contextual Dissimilarity Measure for Accurate and Efficient Image
Search.”</span> In <em>2007 IEEE Conference on Computer Vision and
Pattern Recognition</em>, 1–8. IEEE.
</div>
<div id="ref-low2013hubness" class="csl-entry">
Low, Thomas, Christian Borgelt, Sebastian Stober, and Andreas
Nürnberger. 2013. <span>“The Hubness Phenomenon: Fact or
Artifact?”</span> In <em>Towards Advanced Data Analysis by Combining
Soft Computing and Statistics</em>, 267–78. Springer.
</div>
<div id="ref-radovanovic2010hubs" class="csl-entry">
Radovanovic, Milos, Alexandros Nanopoulos, and Mirjana Ivanovic. 2010.
<span>“Hubs in Space: Popular Nearest Neighbors in High-Dimensional
Data.”</span> <em>Journal of Machine Learning Research</em> 11 (sept):
2487–2531.
</div>
<div id="ref-schnitzer2012local" class="csl-entry">
Schnitzer, Dominik, Arthur Flexer, Markus Schedl, and Gerhard Widmer.
2012. <span>“Local and Global Scaling Reduce Hubs in Space.”</span>
<em>The Journal of Machine Learning Research</em> 13 (1): 2871–2902.
</div>
<div id="ref-JMLR:v22:20-1061" class="csl-entry">
Wang, Yingfan, Haiyang Huang, Cynthia Rudin, and Yaron Shaposhnik. 2021.
<span>“Understanding How Dimension Reduction Tools Work: An Empirical
Approach to Deciphering t-SNE, UMAP, TriMap, and PaCMAP for Data
Visualization.”</span> <em>Journal of Machine Learning Research</em> 22
(201): 1–73. <a href="http://jmlr.org/papers/v22/20-1061.html" class="external-link">http://jmlr.org/papers/v22/20-1061.html</a>.
</div>
<div id="ref-NIPS2004_40173ea4" class="csl-entry">
Zelnik-manor, Lihi, and Pietro Perona. 2005. <span>“Self-Tuning Spectral
Clustering.”</span> In <em>Advances in Neural Information Processing
Systems</em>, edited by L. Saul, Y. Weiss, and L. Bottou. Vol. 17. MIT
Press. <a href="https://proceedings.neurips.cc/paper/2004/file/40173ea48d9567f1f393b20c855bb40b-Paper.pdf" class="external-link">https://proceedings.neurips.cc/paper/2004/file/40173ea48d9567f1f393b20c855bb40b-Paper.pdf</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by James Melville.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
